@page "/catalog"
@using Models
@using AntDesign
@implements IDisposable
@inject AppStateService AppStateService
@inject IDataService DataService

<PageTitle>Catalog</PageTitle>

@if (_tomatoes == null)
{
    <p><em>Loading Cards...</em></p>
}
else
{
    <CatalogSearch></CatalogSearch>

    <div class="search-results">
        
        @if (_tomatoes == null)
        {
            <p><em>Loading Cards...</em></p>
        }
        else
        {
            if (_tomatoes.Length == 0) {
                <p>No results matching search criteria</p>
            } else {
                @foreach (var tomato in _tomatoes)
                {
                    <div @onclick="() => showDetails(tomato.DocumentId)" style="display:flex;">
                        <Card Bordered="true" Title=@tomato.Variety style="width: 300px; margin:10px; cursor:pointer;" >
                            <TitleTemplate>
                                <Icon Type="info-circle" Theme="fill" /> @tomato.Variety
                            </TitleTemplate>
                            <Body>
                                <p>@tomato.Description</p>
                            </Body>
                        </Card>
                    </div>
                }
            }
        }
       
    </div>

    <CatalogDetail Visible=@visible @ref="catalogDetailRef" OnDetailClosed="ResetVisible"></CatalogDetail>

}

@code {

    //[CascadingParameter] public CascadingAppState cascadingAppState { get; set; }

    private Tomato[]? _tomatoes;
    private CatalogDetail? catalogDetailRef;

    [Parameter]
    public string SearchTerm { get; set; }

    //protected override void OnInitialized()
    protected override async Task OnInitializedAsync()
    {
        //// Keywords to search
        //string[] keywords = { "Lap", "Key" };

        //// Perform keyword search using LINQ
        //var searchResults = products
        //    .Where(product => keywords.Any(keyword => product.Name.Contains(keyword, StringComparison.OrdinalIgnoreCase)))
        //    .ToList();

        //Handle in case of refresh since this will fire before the app state is loaded. Else if navigating back, just reload the data from state.
        //if ( cascadingAppState.Tomatoes != null) {
        //    if (!String.IsNullOrWhiteSpace(cascadingAppState.SearchTerm)){
        //        _tomatoes = filterListBySearchTerm();
        //    } else {
        //        _tomatoes = cascadingAppState.Tomatoes;
        //    }
        //}

        if (AppStateService.Tomatoes == null) {
            var tomatoes = await DataService.GetTomatoesAsync();
            _tomatoes = tomatoes.ToArray();
            AppStateService.UpdateTomatoList(this, _tomatoes);
        } else {
            if (!String.IsNullOrWhiteSpace(AppStateService.SearchTerm))
            {
                _tomatoes = filterListBySearchTerm();
            } else {
                _tomatoes = AppStateService.Tomatoes;
            }
        }

        //AppStateService.StateChanged += async (Source, Property) => await AppState_StateChanged(Source, Property);

        AppStateService.StateChanged += StateChanged;
    }

    private void StateChanged(object Source, string Property)
    {
        if (Source != this)
        {
            if (Property == "Tomatoes")
            {
                //_tomatoes = cascadingAppState.Tomatoes;
                _tomatoes = AppStateService.Tomatoes;
                StateHasChanged();
            }

            if (Property == "SearchTerm")
            {
                _tomatoes = filterListBySearchTerm();
                StateHasChanged();
            }
        }
    }


    private async Task AppState_StateChanged(ComponentBase Source, string Property)
    {
        if (Source != this)
        {
            if (Property == "Tomatoes") {
                //_tomatoes = cascadingAppState.Tomatoes;
                _tomatoes = AppStateService.Tomatoes;
                await InvokeAsync(StateHasChanged);
            }

            if (Property == "SearchTerm") {
                _tomatoes = filterListBySearchTerm();
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private Tomato[] filterListBySearchTerm() {
        //return cascadingAppState.Tomatoes.Where(t => t.Description.Contains(cascadingAppState.SearchTerm, StringComparison.OrdinalIgnoreCase)).ToArray();
        var tomatoes = AppStateService.Tomatoes.Where(t => t.Description.Contains(AppStateService.SearchTerm, StringComparison.OrdinalIgnoreCase)).ToArray();
        return tomatoes;
    }

    void IDisposable.Dispose() {
        //cascadingAppState.StateChanged -= async (Source, Property) => await AppState_StateChanged(Source, Property);
        //AppStateService.StateChanged -= async (Source, Property) => await AppState_StateChanged(Source, Property);
        AppStateService.StateChanged -= StateChanged;
    }

    bool visible = false;

    void showDetails(string documentId)
    {
        this.visible = true;
        catalogDetailRef.Id = documentId;
    }

    private void ResetVisible()
    {
        this.visible = false;
    }
}
